/*!
 * Chirpy v5.6.0 (https://github.com/cotes2020/jekyll-theme-chirpy/)
 * Â© 2019 Cotes Chung
 * MIT Licensed
 */

(function () {
  'use strict';

  /**
   * Reference: https://bootsnipp.com/snippets/featured/link-to-top-page
   */

  function back2top() {
    $(window).on('scroll', function () {
      if ($(window).scrollTop() > 50 && $('#sidebar-trigger').css('display') === 'none') {
        $('#back-to-top').fadeIn();
      } else {
        $('#back-to-top').fadeOut();
      }
    });
    $('#back-to-top').on('click', function () {
      $('body,html').animate({
        scrollTop: 0
      }, 800);
      return false;
    });
  }

  /**
   * Initial Bootstrap Tooltip.
   */
  function loadTooptip() {
    $('[data-toggle="tooltip"]').tooltip();
  }

  function basic() {
    back2top();
    loadTooptip();
  }

  /**
   * Add listener for theme mode toggle
   */
  var $toggleElem = $('.mode-toggle');
  function modeWatcher() {
    if ($toggleElem.length === 0) {
      return;
    }
    $toggleElem.off().on('click', function (e) {
      var $target = $(e.target);
      var $btn = $target.prop('tagName') === 'button'.toUpperCase() ? $target : $target.parent();
      modeToggle.flipMode(); // modeToggle: `_includes/mode-toggle.html`
      $btn.trigger('blur'); // remove the clicking outline
    });
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  /**
   * Expand or close the sidebar in mobile screens.
   */

  var $body$1 = $('body');
  var ATTR_DISPLAY = 'sidebar-display';
  var SidebarUtil = /*#__PURE__*/function () {
    function SidebarUtil() {
      _classCallCheck(this, SidebarUtil);
    }
    _createClass(SidebarUtil, null, [{
      key: "toggle",
      value: function toggle() {
        if (SidebarUtil.isExpanded === false) {
          $body$1.attr(ATTR_DISPLAY, '');
        } else {
          $body$1.removeAttr(ATTR_DISPLAY);
        }
        SidebarUtil.isExpanded = !SidebarUtil.isExpanded;
      }
    }]);
    return SidebarUtil;
  }();
  _defineProperty(SidebarUtil, "isExpanded", false);
  function sidebarExpand() {
    $('#sidebar-trigger').on('click', SidebarUtil.toggle);
    $('#mask').on('click', SidebarUtil.toggle);
  }

  function initSidebar() {
    modeWatcher();
    sidebarExpand();
  }

  /**
   * Top bar title auto change while scrolling up/down in mobile screens.
   */
  var titleSelector = 'div.post>h1:first-of-type';
  var $pageTitle = $(titleSelector);
  var $topbarTitle$1 = $('#topbar-title');
  var defaultTitleText = $topbarTitle$1.text().trim();
  function convertTitle() {
    if ($pageTitle.length === 0 /* on Home page */ || $pageTitle.hasClass('dynamic-title') || $topbarTitle$1.is(':hidden')) {
      /* not in mobile views */
      return;
    }
    var pageTitleText = $pageTitle.text().trim();
    var hasScrolled = false;
    var lastScrollTop = 0;
    if ($('#page-category').length || $('#page-tag').length) {
      /* The title in Category or Tag page will be "<title> <count_of_posts>" */
      if (/\s/.test(pageTitleText)) {
        pageTitleText = pageTitleText.replace(/[0-9]/g, '').trim();
      }
    }

    // When the page is scrolled down and then refreshed, the topbar title needs to be initialized
    if ($pageTitle.offset().top < $(window).scrollTop()) {
      $topbarTitle$1.text(pageTitleText);
    }
    var options = {
      rootMargin: '-48px 0px 0px 0px',
      // 48px equals to the topbar height (3rem)
      threshold: [0, 1]
    };
    var observer = new IntersectionObserver(function (entries) {
      if (!hasScrolled) {
        hasScrolled = true;
        return;
      }
      var curScrollTop = $(window).scrollTop();
      var isScrollDown = lastScrollTop < curScrollTop;
      lastScrollTop = curScrollTop;
      var heading = entries[0];
      if (isScrollDown) {
        if (heading.intersectionRatio === 0) {
          $topbarTitle$1.text(pageTitleText);
        }
      } else {
        if (heading.intersectionRatio === 1) {
          $topbarTitle$1.text(defaultTitleText);
        }
      }
    }, options);
    observer.observe(document.querySelector(titleSelector));

    /* Click title will scroll to top */
    $topbarTitle$1.on('click', function () {
      $('body,html').animate({
        scrollTop: 0
      }, 800);
    });
  }

  /**
   * This script make #search-result-wrapper switch to unloaded or shown automatically.
   */
  var $btnSbTrigger = $('#sidebar-trigger');
  var $btnSearchTrigger = $('#search-trigger');
  var $btnCancel = $('#search-cancel');
  var $main = $('#main');
  var $topbarTitle = $('#topbar-title');
  var $searchWrapper = $('#search-wrapper');
  var $resultWrapper = $('#search-result-wrapper');
  var $results = $('#search-results');
  var $input = $('#search-input');
  var $hints = $('#search-hints');
  var $viewport = $('html,body');

  // class names
  var C_LOADED = 'loaded';
  var C_UNLOADED = 'unloaded';
  var C_FOCUS = 'input-focus';
  var C_FLEX = 'd-flex';
  var ScrollBlocker = /*#__PURE__*/function () {
    function ScrollBlocker() {
      _classCallCheck(this, ScrollBlocker);
    }
    _createClass(ScrollBlocker, null, [{
      key: "on",
      value: function on() {
        ScrollBlocker.offset = window.scrollY;
        $viewport.scrollTop(0);
      }
    }, {
      key: "off",
      value: function off() {
        $viewport.scrollTop(ScrollBlocker.offset);
      }
    }]);
    return ScrollBlocker;
  }();
  /*--- Actions in mobile screens (Sidebar hidden) ---*/
  _defineProperty(ScrollBlocker, "offset", 0);
  _defineProperty(ScrollBlocker, "resultVisible", false);
  var MobileSearchBar = /*#__PURE__*/function () {
    function MobileSearchBar() {
      _classCallCheck(this, MobileSearchBar);
    }
    _createClass(MobileSearchBar, null, [{
      key: "on",
      value: function on() {
        $btnSbTrigger.addClass(C_UNLOADED);
        $topbarTitle.addClass(C_UNLOADED);
        $btnSearchTrigger.addClass(C_UNLOADED);
        $searchWrapper.addClass(C_FLEX);
        $btnCancel.addClass(C_LOADED);
      }
    }, {
      key: "off",
      value: function off() {
        $btnCancel.removeClass(C_LOADED);
        $searchWrapper.removeClass(C_FLEX);
        $btnSbTrigger.removeClass(C_UNLOADED);
        $topbarTitle.removeClass(C_UNLOADED);
        $btnSearchTrigger.removeClass(C_UNLOADED);
      }
    }]);
    return MobileSearchBar;
  }();
  var ResultSwitch = /*#__PURE__*/function () {
    function ResultSwitch() {
      _classCallCheck(this, ResultSwitch);
    }
    _createClass(ResultSwitch, null, [{
      key: "on",
      value: function on() {
        if (!ScrollBlocker.resultVisible) {
          // the block method must be called before $(#main) unloaded.
          ScrollBlocker.on();
          $resultWrapper.removeClass(C_UNLOADED);
          $main.addClass(C_UNLOADED);
          ScrollBlocker.resultVisible = true;
        }
      }
    }, {
      key: "off",
      value: function off() {
        if (ScrollBlocker.resultVisible) {
          $results.empty();
          if ($hints.hasClass(C_UNLOADED)) {
            $hints.removeClass(C_UNLOADED);
          }
          $resultWrapper.addClass(C_UNLOADED);
          $main.removeClass(C_UNLOADED);

          // now the release method must be called after $(#main) display
          ScrollBlocker.off();
          $input.val('');
          ScrollBlocker.resultVisible = false;
        }
      }
    }]);
    return ResultSwitch;
  }();
  function isMobileView() {
    return $btnCancel.hasClass(C_LOADED);
  }
  function displaySearch() {
    $btnSearchTrigger.on('click', function () {
      MobileSearchBar.on();
      ResultSwitch.on();
      $input.trigger('focus');
    });
    $btnCancel.on('click', function () {
      MobileSearchBar.off();
      ResultSwitch.off();
    });
    $input.on('focus', function () {
      $searchWrapper.addClass(C_FOCUS);
    });
    $input.on('focusout', function () {
      $searchWrapper.removeClass(C_FOCUS);
    });
    $input.on('input', function () {
      if ($input.val() === '') {
        if (isMobileView()) {
          $hints.removeClass(C_UNLOADED);
        } else {
          ResultSwitch.off();
        }
      } else {
        ResultSwitch.on();
        if (isMobileView()) {
          $hints.addClass(C_UNLOADED);
        }
      }
    });
  }

  /**
   * A tool for smooth scrolling and topbar switcher
   */

  var ATTR_TOPBAR_VISIBLE = 'data-topbar-visible';
  var $body = $('body');
  var $topbarWrapper = $('#topbar-wrapper');
  var ScrollHelper = /*#__PURE__*/function () {
    function ScrollHelper() {
      _classCallCheck(this, ScrollHelper);
    }
    _createClass(ScrollHelper, null, [{
      key: "hideTopbar",
      value:
      // the number of times the scroll up was triggered by ToC or anchor

      function hideTopbar() {
        $body.attr(ATTR_TOPBAR_VISIBLE, 'false');
      }
    }, {
      key: "showTopbar",
      value: function showTopbar() {
        $body.attr(ATTR_TOPBAR_VISIBLE, 'true');
      }

      // scroll up
    }, {
      key: "addScrollUpTask",
      value: function addScrollUpTask() {
        ScrollHelper.scrollUpCount += 1;
        if (!ScrollHelper.topbarIsLocked) {
          ScrollHelper.topbarIsLocked = true;
        }
      }
    }, {
      key: "popScrollUpTask",
      value: function popScrollUpTask() {
        ScrollHelper.scrollUpCount -= 1;
      }
    }, {
      key: "hasScrollUpTask",
      value: function hasScrollUpTask() {
        return ScrollHelper.scrollUpCount > 0;
      }
    }, {
      key: "topbarLocked",
      value: function topbarLocked() {
        return ScrollHelper.topbarIsLocked === true;
      }
    }, {
      key: "unlockTopbar",
      value: function unlockTopbar() {
        ScrollHelper.topbarIsLocked = false;
      }
    }, {
      key: "getTopbarHeight",
      value: function getTopbarHeight() {
        return $topbarWrapper.outerHeight();
      }

      // orientation change
    }, {
      key: "orientationLocked",
      value: function orientationLocked() {
        return ScrollHelper.orientationIsLocked === true;
      }
    }, {
      key: "lockOrientation",
      value: function lockOrientation() {
        ScrollHelper.orientationIsLocked = true;
      }
    }, {
      key: "unLockOrientation",
      value: function unLockOrientation() {
        ScrollHelper.orientationIsLocked = false;
      }
    }]);
    return ScrollHelper;
  }();
  _defineProperty(ScrollHelper, "scrollUpCount", 0);
  _defineProperty(ScrollHelper, "topbarIsLocked", false);
  _defineProperty(ScrollHelper, "orientationIsLocked", false);

  /**
   * Hide Header on scroll down
   */
  var $searchInput = $('#search-input');
  var delta = ScrollHelper.getTopbarHeight();
  var didScroll;
  var lastScrollTop = 0;
  function hasScrolled() {
    var st = $(window).scrollTop();

    /* Make sure they scroll more than delta */
    if (Math.abs(lastScrollTop - st) <= delta) {
      return;
    }
    if (st > lastScrollTop) {
      /* Scroll down */
      ScrollHelper.hideTopbar();
      if ($searchInput.is(':focus')) {
        $searchInput.trigger('blur'); /* remove focus */
      }
    } else {
      /* Scroll up */

      // has not yet scrolled to the bottom of the screen, that is, there is still space for scrolling
      if (st + $(window).height() < $(document).height()) {
        if (ScrollHelper.hasScrollUpTask()) {
          return;
        }
        if (ScrollHelper.topbarLocked()) {
          // avoid redundant scroll up event from smooth scrolling
          ScrollHelper.unlockTopbar();
        } else {
          if (ScrollHelper.orientationLocked()) {
            // avoid device auto scroll up on orientation change
            ScrollHelper.unLockOrientation();
          } else {
            ScrollHelper.showTopbar();
          }
        }
      }
    }
    lastScrollTop = st;
  } // hasScrolled()

  function handleLandscape() {
    if ($(window).scrollTop() === 0) {
      return;
    }
    ScrollHelper.lockOrientation();
    ScrollHelper.hideTopbar();
  }
  function switchTopbar() {
    var orientation = screen.orientation;
    if (orientation) {
      orientation.onchange = function () {
        var type = orientation.type;
        if (type === 'landscape-primary' || type === 'landscape-secondary') {
          handleLandscape();
        }
      };
    } else {
      // for the browsers that not support `window.screen.orientation` API
      $(window).on('orientationchange', function () {
        if ($(window).width() < $(window).height()) {
          // before rotating, it is still in portrait mode.
          handleLandscape();
        }
      });
    }
    $(window).on('scroll', function () {
      if (didScroll) {
        return;
      }
      didScroll = true;
    });
    setInterval(function () {
      if (didScroll) {
        hasScrolled();
        didScroll = false;
      }
    }, 250);
  }

  function initTopbar() {
    convertTitle();
    displaySearch();
    switchTopbar();
  }

  /**
   * Tab 'Categories' expand/close effect.
   */
  $('.collapse');

  /**
   * Clipboard functions
   *
   * Dependencies:
   *   - popper.js (https://github.com/popperjs/popper-core)
   *   - clipboard.js (https://github.com/zenorocha/clipboard.js)
   */

  var btnSelector = '.code-header>button';
  var ICON_SUCCESS = 'bi bi-check';
  var ATTR_TIMEOUT = 'timeout';
  var ATTR_TITLE_SUCCEED = 'data-title-succeed';
  var ATTR_TITLE_ORIGIN = 'data-original-title';
  var TIMEOUT = 2000; // in milliseconds

  function isLocked(node) {
    if ($(node)[0].hasAttribute(ATTR_TIMEOUT)) {
      var timeout = $(node).attr(ATTR_TIMEOUT);
      if (Number(timeout) > Date.now()) {
        return true;
      }
    }
    return false;
  }
  function lock(node) {
    $(node).attr(ATTR_TIMEOUT, Date.now() + TIMEOUT);
  }
  function unlock(node) {
    $(node).removeAttr(ATTR_TIMEOUT);
  }
  function getIcon(btn) {
    var iconNode = $(btn).children();
    return iconNode.attr('class');
  }
  var ICON_DEFAULT = getIcon(btnSelector);
  function showTooltip(btn) {
    var succeedTitle = $(btn).attr(ATTR_TITLE_SUCCEED);
    $(btn).attr(ATTR_TITLE_ORIGIN, succeedTitle).tooltip('show');
  }
  function hideTooltip(btn) {
    $(btn).tooltip('hide').removeAttr(ATTR_TITLE_ORIGIN);
  }
  function setSuccessIcon(btn) {
    var btnNode = $(btn);
    var iconNode = btnNode.children();
    iconNode.attr('class', ICON_SUCCESS);
  }
  function resumeIcon(btn) {
    var btnNode = $(btn);
    var iconNode = btnNode.children();
    iconNode.attr('class', ICON_DEFAULT);
  }
  function initClipboard() {
    // Initial the clipboard.js object
    var clipboard = new ClipboardJS(btnSelector, {
      target: function target(trigger) {
        var codeBlock = trigger.parentNode.nextElementSibling;
        return codeBlock.querySelector('code .rouge-code');
      }
    });
    $(btnSelector).tooltip({
      trigger: 'hover',
      placement: 'left'
    });
    clipboard.on('success', function (e) {
      e.clearSelection();
      var trigger = e.trigger;
      if (isLocked(trigger)) {
        return;
      }
      setSuccessIcon(trigger);
      showTooltip(trigger);
      lock(trigger);
      setTimeout(function () {
        hideTooltip(trigger);
        resumeIcon(trigger);
        unlock(trigger);
      }, TIMEOUT);
    });

    /* --- Post link sharing --- */

    $('#copy-link').on('click', function (e) {
      var target = $(e.target);
      if (isLocked(target)) {
        return;
      }

      // Copy URL to clipboard
      navigator.clipboard.writeText(window.location.href).then(function () {
        var defaultTitle = target.attr(ATTR_TITLE_ORIGIN);
        var succeedTitle = target.attr(ATTR_TITLE_SUCCEED);
        // Switch tooltip title
        target.attr(ATTR_TITLE_ORIGIN, succeedTitle).tooltip('show');
        lock(target);
        setTimeout(function () {
          target.attr(ATTR_TITLE_ORIGIN, defaultTitle);
          unlock(target);
        }, TIMEOUT);
      });
    });
  }

  /**
   * Set up image stuff
   */

  function imgExtra() {
    if ($('#core-wrapper img[data-src]') <= 0) {
      return;
    }

    /* See: <https://github.com/dimsemenov/Magnific-Popup> */
    $('.popup').magnificPopup({
      type: 'image',
      closeOnContentClick: true,
      showCloseBtn: false,
      zoom: {
        enabled: true,
        duration: 300,
        easing: 'ease-in-out'
      }
    });

    /* Stop shimmer when image loaded */
    document.addEventListener('lazyloaded', function (e) {
      var $img = $(e.target);
      $img.parent().removeClass('shimmer');
    });
  }

  /**
   * Update month/day to locale datetime
   *
   * Requirement: <https://github.com/iamkun/dayjs>
   */
  /* A tool for locale datetime */
  var LocaleHelper = /*#__PURE__*/function () {
    function LocaleHelper() {
      _classCallCheck(this, LocaleHelper);
    }
    _createClass(LocaleHelper, null, [{
      key: "attrTimestamp",
      get: function get() {
        return 'data-ts';
      }
    }, {
      key: "attrDateFormat",
      get: function get() {
        return 'data-df';
      }
    }, {
      key: "locale",
      get: function get() {
        return $('html').attr('lang').substring(0, 2);
      }
    }, {
      key: "getTimestamp",
      value: function getTimestamp(elem) {
        return Number(elem.attr(LocaleHelper.attrTimestamp)); // unix timestamp
      }
    }, {
      key: "getDateFormat",
      value: function getDateFormat(elem) {
        return elem.attr(LocaleHelper.attrDateFormat);
      }
    }]);
    return LocaleHelper;
  }();
  function initLocaleDatetime() {
    dayjs.locale(LocaleHelper.locale);
    dayjs.extend(window.dayjs_plugin_localizedFormat);
    $("[".concat(LocaleHelper.attrTimestamp, "]")).each(function () {
      var date = dayjs.unix(LocaleHelper.getTimestamp($(this)));
      var text = date.format(LocaleHelper.getDateFormat($(this)));
      $(this).text(text);
      $(this).removeAttr(LocaleHelper.attrTimestamp);
      $(this).removeAttr(LocaleHelper.attrDateFormat);

      // setup tooltips
      var tooltip = $(this).attr('data-toggle');
      if (typeof tooltip === 'undefined' || tooltip !== 'tooltip') {
        return;
      }
      var tooltipText = date.format('llll'); // see: https://day.js.org/docs/en/display/format#list-of-localized-formats
      $(this).attr('data-original-title', tooltipText);
    });
  }

  /**
   * Count page views form GA or local cache file.
   *
   * Dependencies:
   *   - jQuery
   *   - countUp.js <https://github.com/inorganik/countUp.js>
   */

  var getInitStatus = function () {
    var hasInit = false;
    return function () {
      var ret = hasInit;
      if (!hasInit) {
        hasInit = true;
      }
      return ret;
    };
  }();
  var PvOpts = function () {
    function getContent(selector) {
      return $(selector).attr('content');
    }
    function hasContent(selector) {
      var content = getContent(selector);
      return typeof content !== 'undefined' && content !== false;
    }
    return {
      getProxyMeta: function getProxyMeta() {
        return getContent('meta[name=pv-proxy-endpoint]');
      },
      getLocalMeta: function getLocalMeta() {
        return getContent('meta[name=pv-cache-path]');
      },
      hasProxyMeta: function hasProxyMeta() {
        return hasContent('meta[name=pv-proxy-endpoint]');
      },
      hasLocalMeta: function hasLocalMeta() {
        return hasContent('meta[name=pv-cache-path]');
      }
    };
  }();
  var PvStorage = function () {
    var Keys = {
      KEY_PV: 'pv',
      KEY_PV_SRC: 'pv_src',
      KEY_CREATION: 'pv_created_date'
    };
    var Source = {
      LOCAL: 'same-origin',
      PROXY: 'cors'
    };
    function get(key) {
      return localStorage.getItem(key);
    }
    function set(key, val) {
      localStorage.setItem(key, val);
    }
    function saveCache(pv, src) {
      set(Keys.KEY_PV, pv);
      set(Keys.KEY_PV_SRC, src);
      set(Keys.KEY_CREATION, new Date().toJSON());
    }
    return {
      keysCount: function keysCount() {
        return Object.keys(Keys).length;
      },
      hasCache: function hasCache() {
        return localStorage.getItem(Keys.KEY_PV) !== null;
      },
      getCache: function getCache() {
        return JSON.parse(localStorage.getItem(Keys.KEY_PV));
      },
      saveLocalCache: function saveLocalCache(pv) {
        saveCache(pv, Source.LOCAL);
      },
      saveProxyCache: function saveProxyCache(pv) {
        saveCache(pv, Source.PROXY);
      },
      isExpired: function isExpired() {
        var date = new Date(get(Keys.KEY_CREATION));
        date.setHours(date.getHours() + 1); // per hour
        return Date.now() >= date.getTime();
      },
      isFromLocal: function isFromLocal() {
        return get(Keys.KEY_PV_SRC) === Source.LOCAL;
      },
      isFromProxy: function isFromProxy() {
        return get(Keys.KEY_PV_SRC) === Source.PROXY;
      },
      newerThan: function newerThan(pv) {
        return PvStorage.getCache().totalsForAllResults['ga:pageviews'] > pv.totalsForAllResults['ga:pageviews'];
      },
      inspectKeys: function inspectKeys() {
        if (localStorage.length !== PvStorage.keysCount()) {
          localStorage.clear();
          return;
        }
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          switch (key) {
            case Keys.KEY_PV:
            case Keys.KEY_PV_SRC:
            case Keys.KEY_CREATION:
              break;
            default:
              localStorage.clear();
              return;
          }
        }
      }
    };
  }(); /* PvStorage */

  function countUp(min, max, destId) {
    if (min < max) {
      var numAnim = new CountUp(destId, min, max);
      if (!numAnim.error) {
        numAnim.start();
      } else {
        console.error(numAnim.error);
      }
    }
  }
  function countPV(path, rows) {
    var count = 0;
    if (typeof rows !== 'undefined') {
      for (var i = 0; i < rows.length; ++i) {
        var gaPath = rows[parseInt(i, 10)][0];
        if (gaPath === path) {
          /* path format see: site.permalink */
          count += parseInt(rows[parseInt(i, 10)][1], 10);
          break;
        }
      }
    }
    return count;
  }
  function tacklePV(rows, path, elem, hasInit) {
    var count = countPV(path, rows);
    count = count === 0 ? 1 : count;
    if (!hasInit) {
      elem.text(new Intl.NumberFormat().format(count));
    } else {
      var initCount = parseInt(elem.text().replace(/,/g, ''), 10);
      if (count > initCount) {
        countUp(initCount, count, elem.attr('id'));
      }
    }
  }
  function displayPageviews(data) {
    if (typeof data === 'undefined') {
      return;
    }
    var hasInit = getInitStatus();
    var rows = data.rows; /* could be undefined */

    if ($('#post-list').length > 0) {
      /* the Home page */
      $('.post-preview').each(function () {
        var path = $(this).find('a').attr('href');
        tacklePV(rows, path, $(this).find('.pageviews'), hasInit);
      });
    } else if ($('.post').length > 0) {
      /* the post */
      var path = window.location.pathname;
      tacklePV(rows, path, $('#pv'), hasInit);
    }
  }
  function fetchProxyPageviews() {
    if (PvOpts.hasProxyMeta()) {
      $.ajax({
        type: 'GET',
        url: PvOpts.getProxyMeta(),
        dataType: 'jsonp',
        jsonpCallback: 'displayPageviews',
        success: function success(data) {
          PvStorage.saveProxyCache(JSON.stringify(data));
        },
        error: function error(jqXHR, textStatus, errorThrown) {
          console.log('Failed to load pageviews from proxy server: ' + errorThrown);
        }
      });
    }
  }
  function fetchLocalPageviews() {
    var hasCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return fetch(PvOpts.getLocalMeta()).then(function (response) {
      return response.json();
    }).then(function (data) {
      if (hasCache) {
        // The cache from the proxy will sometimes be more recent than the local one
        if (PvStorage.isFromProxy() && PvStorage.newerThan(data)) {
          return;
        }
      }
      displayPageviews(data);
      PvStorage.saveLocalCache(JSON.stringify(data));
    });
  }
  function initPageviews() {
    if ($('.pageviews').length <= 0) {
      return;
    }
    PvStorage.inspectKeys();
    if (PvStorage.hasCache()) {
      displayPageviews(PvStorage.getCache());
      if (PvStorage.isExpired()) {
        if (PvOpts.hasLocalMeta()) {
          fetchLocalPageviews(true).then(fetchProxyPageviews);
        } else {
          fetchProxyPageviews();
        }
      } else {
        if (PvStorage.isFromLocal()) {
          fetchProxyPageviews();
        }
      }
    } else {
      // no cached

      if (PvOpts.hasLocalMeta()) {
        fetchLocalPageviews().then(fetchProxyPageviews);
      } else {
        fetchProxyPageviews();
      }
    }
  }

  /**
   Safari doesn't support CSS `scroll-behavior: smooth`,
   so here is a compatible solution for all browser to smooth scrolling

   See: <https://css-tricks.com/snippets/jquery/smooth-scrolling/>

   Warning: It must be called after all `<a>` tags (e.g., the dynamic TOC) are ready.
   */
  function smoothScroll() {
    var $topbarTitle = $('#topbar-title');
    var REM = 16; // in pixels
    var ATTR_SCROLL_FOCUS = 'scroll-focus';
    var SCOPE = "a[href*='#']:not([href='#']):not([href='#0'])";
    $(SCOPE).on('click', function (event) {
      if (this.pathname.replace(/^\//, '') !== location.pathname.replace(/^\//, '')) {
        return;
      }
      if (location.hostname !== this.hostname) {
        return;
      }
      var hash = decodeURI(this.hash);
      var toFootnoteRef = RegExp(/^#fnref:/).test(hash);
      var toFootnote = toFootnoteRef ? false : RegExp(/^#fn:/).test(hash);
      var selector = '#' + $.escapeSelector(hash.substring(1));
      var $target = $(selector);
      var isMobileViews = $topbarTitle.is(':visible');
      var isPortrait = $(window).width() < $(window).height();
      if (typeof $target === 'undefined') {
        return;
      }
      event.preventDefault();
      if (history.pushState) {
        /* add hash to URL */
        history.pushState(null, null, hash);
      }
      var curOffset = $(window).scrollTop();
      var destOffset = $target.offset().top -= REM / 2;
      if (destOffset < curOffset) {
        // scroll up
        ScrollHelper.hideTopbar();
        ScrollHelper.addScrollUpTask();
        if (isMobileViews && isPortrait) {
          destOffset -= ScrollHelper.getTopbarHeight();
        }
      } else {
        // scroll down
        if (isMobileViews && isPortrait) {
          destOffset -= ScrollHelper.getTopbarHeight();
        }
      }
      $('html').animate({
        scrollTop: destOffset
      }, 500, function () {
        $target.trigger('focus');

        /* clean up old scroll mark */
        var $scroll_focus = $("[".concat(ATTR_SCROLL_FOCUS, "=true]"));
        if ($scroll_focus.length) {
          $scroll_focus.attr(ATTR_SCROLL_FOCUS, 'false');
        }

        /* Clean :target links */
        var $target_links = $(':target');
        if ($target_links.length) {
          /* element that visited by the URL with hash */
          $target_links.attr(ATTR_SCROLL_FOCUS, 'false');
        }

        /* set scroll mark to footnotes */
        if (toFootnote || toFootnoteRef) {
          $target.attr(ATTR_SCROLL_FOCUS, 'true');
        }
        if ($target.is(':focus')) {
          /* Checking if the target was focused */
          return false;
        } else {
          $target.attr('tabindex', '-1'); /* Adding tabindex for elements not focusable */
          $target.trigger('focus'); /* Set focus again */
        }

        if (ScrollHelper.hasScrollUpTask()) {
          ScrollHelper.popScrollUpTask();
        }
      });
    }); /* click() */
  }

  function toc() {
    if (document.querySelector('#core-wrapper h2,#core-wrapper h3')) {
      // see: https://github.com/tscanlin/tocbot#usage
      tocbot.init({
        tocSelector: '#toc',
        contentSelector: '.post-content',
        ignoreSelector: '[data-toc-skip]',
        headingSelector: 'h2, h3',
        orderedList: false,
        scrollSmooth: false
      });
    }
  }

  var ATTR_POSTED_DATE = 'posted-date';
  var ATTR_UPDATED_DATE = 'updated-date';
  function postAgeNotification() {
    // Assign the target node containing the HTML message to a variable
    var postNotification = document.getElementById('post-age-notification');

    // Read the contents of the 'div' containing the posted date
    var postDate = Number(document.getElementById(ATTR_POSTED_DATE).innerHTML);

    // Read the contents of the 'div' containing the post's last update date
    var updatedDate = Number(document.getElementById(ATTR_UPDATED_DATE).innerHTML);

    // Check if the updated date is newer than the posted date
    // if it is then use the updated date, else use the postDate
    var postCheckDate = updatedDate > postDate ? updatedDate : postDate;

    // Get the current age of the post by subtracting the post's timestamp from the current UNIX timestamp when the page is loaded, i.e. right now
    var postAge = Math.floor(new Date().getTime() / 1000.0) - postCheckDate;

    // Calculate the age in months by dividing the post's age by the number of seconds in a month, and rounding it down to an integer
    var postAgeMonths = Math.floor(postAge / 2629746);

    // If the post age (in months) is greater than 6 (months), then remove the hidden CSS class from the target node, and insert the HTML message
    if (postAgeMonths > 6) {
      postNotification.classList.remove('d-none');
      postNotification.innerHTML = "This post is ".concat(postAgeMonths, " months old. Some information may be outdated or inaccurate.<br>If any updates are required please comment at the bottom of the page.");
    }
  }

  basic();
  initSidebar();
  initTopbar();
  imgExtra();
  initLocaleDatetime();
  initClipboard();
  toc();
  smoothScroll(); // must be called after toc is created
  initPageviews();
  postAgeNotification();

})();
//# sourceMappingURL=post.min.js.map
